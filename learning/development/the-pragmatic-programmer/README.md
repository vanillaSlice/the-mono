# The Pragmatic Programmer by David Thomas and Andrew Hunt

![Cover](./cover.jpg)

## Chapter One: A Pragmatic Philosophy

* It's your life, you have agency
* Make changes in your job or change your job
* Take responsibility, provide options, don't make lame excuses
* Don't live with broken windows
* Be a catalyst for change
* Remember the big picture
* Make quality a requirements issue
* Invest regularly in your knowledge portfolio
  * Learn at least one new language every year
  * Read a technical book each month
  * Read non-technical books too
  * Take classes
  * Participate in local users groups and meet-ups
  * Experiment with different environments
  * Stay current
* Critically analyse what you read and hear
* Communication:
  * English is just another programming language
  * Know your audience
  * Know what you want to say
  * Choose your moment, make what you're saying relevant in time
  * Choose a style to suit your audience
  * Make it look good
  * Involve your audience
  * Be a listener
  * Get back to people
  * Build documentation in, don't bolt it on

## Chapter Two: A Pragmatic Approach

* Good design is easier to change than bad design
* DRY - Don't Repeat Yourself
  * Coincidences are not duplication - don't de-duplicate these
  * Don't duplicate code in comments
  * Duplication can occur between developers, ensure communication
  * Make it easy to reuse
* Orthogonality in computing refers to system independence
  * Changes in one system do not affect any of the others
  * Eliminate effects between unrelated things
  * Orthogonal systems are reusable
* There are no final decisions, build systems that can reverse decisions (e.g. database vendors)
* Forgo following fads
* Use tracer bullets to find the target
  * Make a simple E2E to prove that components can communicate successfully and prove out a feature
  * Users get to see something early
  * Developers build a structure to work in
  * You have an integration platform
  * You have something to demonstrate
  * You have a better feel for progress
  * It is not prototyping, tracer bullets are kept
* Prototype to learn
  * Ensure everyone knows this is throwaway code
* Program close to the problem domain (e.g. Cucumber)
* Estimate to avoid surprises
  * Ask how long people took to complete a similar project
  * Estimate subtasks
  * Give a range of numbers (best, worst, and likely cases)
* Iterate the schedule with code

## Chapter Three: The Basic Tools

* Keep knowledge in plain text
* Use the power of command shells
